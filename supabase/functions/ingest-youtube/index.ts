import { serve } from "https://deno.land/std@0.168.0/http/server.ts";
import { createClient } from "https://esm.sh/@supabase/supabase-js@2";

const corsHeaders = {
  "Access-Control-Allow-Origin": "*",
  "Access-Control-Allow-Headers": "authorization, x-client-info, apikey, content-type",
};

// Extract video ID from YouTube URL
function extractVideoId(url: string): string | null {
  const patterns = [
    /(?:youtube\.com\/watch\?v=|youtu\.be\/)([^&\n?#]+)/,
    /youtube\.com\/embed\/([^&\n?#]+)/,
  ];
  
  for (const pattern of patterns) {
    const match = url.match(pattern);
    if (match && match[1]) return match[1];
  }
  
  return null;
}

// Extract all available metadata from YouTube page
function extractVideoMetadata(html: string, videoId: string): {
  title: string;
  description: string;
  chapters: string[];
  duration: number | null;
  keywords: string[];
  channelName: string;
} {
  // Extract title
  const titleMatch = html.match(/<meta property="og:title" content="([^"]+)"/);
  const title = titleMatch ? titleMatch[1] : `YouTube Video ${videoId}`;
  
  // Extract description - try multiple patterns
  let description = '';
  const descPatterns = [
    /"description":\{"simpleText":"([^"]+)"/,
    /<meta property="og:description" content="([^"]+)"/,
    /"shortDescription":"([^"]+)"/,
  ];
  
  for (const pattern of descPatterns) {
    const match = html.match(pattern);
    if (match && match[1] && match[1].length > description.length) {
      description = match[1].replace(/\\n/g, '\n').replace(/\\"/g, '"');
    }
  }
  
  // Extract chapters from description or structured data
  const chapters: string[] = [];
  const chapterPattern = /(\d{1,2}:\d{2}(?::\d{2})?)\s*[-â€“]\s*(.+?)(?=\n|\d{1,2}:\d{2}|$)/g;
  let chapterMatch;
  while ((chapterMatch = chapterPattern.exec(description)) !== null) {
    chapters.push(`${chapterMatch[1]} - ${chapterMatch[2].trim()}`);
  }
  
  // Extract duration
  const durationMatch = html.match(/"lengthSeconds":"(\d+)"/);
  const duration = durationMatch ? parseInt(durationMatch[1], 10) : null;
  
  // Extract keywords
  const keywordsMatch = html.match(/<meta name="keywords" content="([^"]+)"/);
  const keywords = keywordsMatch 
    ? keywordsMatch[1].split(',').map(k => k.trim()).filter(k => k.length > 0)
    : [];
  
  // Extract channel name
  const channelMatch = html.match(/"ownerChannelName":"([^"]+)"/);
  const channelName = channelMatch ? channelMatch[1] : '';
  
  return { title, description, chapters, duration, keywords, channelName };
}

// Step 1: Try fetching transcript via timedtext API (no API key needed)
async function fetchTimedtextTranscript(videoId: string): Promise<string | null> {
  try {
    console.log(`[timedtext] Fetching captions for video: ${videoId}`);
    
    // Try multiple language codes
    const langCodes = ['en', 'en-US', 'hi', 'hi-IN', 'en-GB', 'a.en', 'a.hi'];
    
    for (const lang of langCodes) {
      try {
        const url = `https://www.youtube.com/api/timedtext?v=${videoId}&lang=${lang}&fmt=json3`;
        const response = await fetch(url, {
          headers: {
            'Accept-Language': 'en-US,en;q=0.9',
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
          }
        });
        
        if (!response.ok) continue;
        
        const text = await response.text();
        if (!text || text.length < 10) continue;
        
        try {
          const data = JSON.parse(text);
          const events = data?.events || [];
          const textSegments: string[] = [];
          
          for (const event of events) {
            if (event.segs) {
              for (const seg of event.segs) {
                if (seg.utf8) {
                  textSegments.push(seg.utf8.trim());
                }
              }
            }
          }
          
          const transcript = textSegments.filter(s => s.length > 0).join(' ');
          
          if (transcript.length > 100) {
            console.log(`[timedtext] âœ“ Found captions in ${lang}: ${transcript.length} chars`);
            return transcript;
          }
        } catch (parseError) {
          continue; // JSON parse failed, try next language
        }
      } catch (e) {
        continue;
      }
    }
    
    console.log('[timedtext] No captions found in any language');
    return null;
  } catch (error) {
    console.error("[timedtext] Error:", error);
    return null;
  }
}

// Step 2: Try auto-generated captions via watch page parsing
async function fetchAutoGeneratedCaptions(html: string): Promise<string | null> {
  try {
    console.log(`[autoCaptions] Attempting to extract captions from page HTML`);
    
    // Look for caption track URLs in the page
    const captionUrlMatch = html.match(/"captionTracks":\s*\[(.*?)\]/);
    if (!captionUrlMatch) {
      console.log('[autoCaptions] No caption tracks found in page');
      return null;
    }
    
    // Parse caption tracks
    try {
      const tracksJson = `[${captionUrlMatch[1]}]`;
      const tracks = JSON.parse(tracksJson);
      
      // Prefer auto-generated English or Hindi
      const preferredTrack = tracks.find((t: any) => 
        t.languageCode?.startsWith('en') || t.languageCode?.startsWith('hi')
      ) || tracks[0];
      
      if (preferredTrack?.baseUrl) {
        const captionUrl = preferredTrack.baseUrl.replace(/\\u0026/g, '&');
        console.log(`[autoCaptions] Found caption URL for ${preferredTrack.languageCode}`);
        
        const captionResponse = await fetch(captionUrl + '&fmt=json3');
        if (captionResponse.ok) {
          const text = await captionResponse.text();
          const data = JSON.parse(text);
          const events = data?.events || [];
          const textSegments: string[] = [];
          
          for (const event of events) {
            if (event.segs) {
              for (const seg of event.segs) {
                if (seg.utf8) {
                  textSegments.push(seg.utf8.trim());
                }
              }
            }
          }
          
          const transcript = textSegments.filter(s => s.length > 0).join(' ');
          if (transcript.length > 100) {
            console.log(`[autoCaptions] âœ“ Got ${transcript.length} chars from auto-captions`);
            return transcript;
          }
        }
      }
    } catch (parseError) {
      console.log('[autoCaptions] Failed to parse caption tracks:', parseError);
    }
    
    return null;
  } catch (error) {
    console.error("[autoCaptions] Error:", error);
    return null;
  }
}

// Step 3: Use Lovable AI to generate educational content from video metadata
async function generateContentWithAI(
  metadata: { title: string; description: string; chapters: string[]; keywords: string[]; channelName: string; duration: number | null },
  videoId: string
): Promise<string | null> {
  try {
    console.log(`[lovableAI] Generating content from video metadata for: ${videoId}`);
    
    const LOVABLE_API_KEY = Deno.env.get("LOVABLE_API_KEY");
    if (!LOVABLE_API_KEY) {
      console.log('[lovableAI] LOVABLE_API_KEY not configured');
      return null;
    }
    
    // Build context from all available metadata
    const contextParts: string[] = [];
    contextParts.push(`Video Title: ${metadata.title}`);
    
    if (metadata.channelName) {
      contextParts.push(`Channel: ${metadata.channelName}`);
    }
    
    if (metadata.duration) {
      const mins = Math.floor(metadata.duration / 60);
      contextParts.push(`Duration: ${mins} minutes`);
    }
    
    if (metadata.description && metadata.description.length > 50) {
      contextParts.push(`\nDescription:\n${metadata.description}`);
    }
    
    if (metadata.chapters.length > 0) {
      contextParts.push(`\nChapters:\n${metadata.chapters.join('\n')}`);
    }
    
    if (metadata.keywords.length > 0) {
      contextParts.push(`\nTopics: ${metadata.keywords.slice(0, 15).join(', ')}`);
    }
    
    const videoContext = contextParts.join('\n');
    
    // Check if we have enough context
    if (videoContext.length < 100) {
      console.log('[lovableAI] Not enough metadata to generate content');
      return null;
    }
    
    console.log(`[lovableAI] Context length: ${videoContext.length} chars`);
    
    const response = await fetch("https://ai.gateway.lovable.dev/v1/chat/completions", {
      method: "POST",
      headers: {
        Authorization: `Bearer ${LOVABLE_API_KEY}`,
        "Content-Type": "application/json",
      },
      body: JSON.stringify({
        model: "google/gemini-2.5-flash",
        messages: [
          {
            role: "system",
            content: `You are an expert educator creating comprehensive study notes from YouTube video metadata.

Your task: Based on the video title, description, chapters, and keywords provided, create detailed educational content that covers the likely topics in this video.

Rules:
1. Expand on each topic/chapter with educational explanations
2. Include key concepts, definitions, and facts that would likely be covered
3. Structure content with clear headings and bullet points
4. Add relevant context that enhances understanding
5. If the video appears to be educational, focus on the subject matter
6. Write 800-2000 words of comprehensive study material
7. Be factual and educational in tone

Output format: Plain text study notes, well-organized with sections.`
          },
          {
            role: "user",
            content: `Create comprehensive study notes based on this YouTube video metadata:\n\n${videoContext}`
          }
        ],
        max_tokens: 4000,
      }),
    });
    
    if (!response.ok) {
      const errorText = await response.text();
      console.error(`[lovableAI] API error: ${response.status} - ${errorText}`);
      
      if (response.status === 429) {
        console.log('[lovableAI] Rate limited');
      }
      return null;
    }
    
    const data = await response.json();
    const content = data.choices?.[0]?.message?.content;
    
    if (content && content.length > 200) {
      console.log(`[lovableAI] âœ“ Generated ${content.length} chars of study content`);
      return `# ${metadata.title}\n\n${content}`;
    }
    
    return null;
  } catch (error) {
    console.error("[lovableAI] Error:", error);
    return null;
  }
}

serve(async (req) => {
  if (req.method === "OPTIONS") {
    return new Response(null, { headers: corsHeaders });
  }

  const correlationId = crypto.randomUUID();
  console.log(`[${correlationId}] Starting YouTube ingestion`);
  
  let sourceId: string | undefined;

  try {
    const body = await req.json();
    sourceId = body.sourceId;

    const supabaseUrl = Deno.env.get("SUPABASE_URL")!;
    const supabaseServiceKey = Deno.env.get("SUPABASE_SERVICE_ROLE_KEY")!;
    const supabase = createClient(supabaseUrl, supabaseServiceKey);

    // Get source
    const { data: source, error: sourceError } = await supabase
      .from("sources")
      .select("*")
      .eq("id", sourceId)
      .single();

    if (sourceError) throw sourceError;

    const videoId = extractVideoId(source.source_url!);
    if (!videoId) {
      throw new Error("Invalid YouTube URL format. Please check the URL and try again.");
    }

    console.log(`[${correlationId}] Processing YouTube video: ${videoId}`);

    // Update status
    await supabase
      .from("sources")
      .update({ status: "processing" })
      .eq("id", sourceId);

    // Fetch video page
    const pageResponse = await fetch(`https://www.youtube.com/watch?v=${videoId}`, {
      headers: {
        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
        'Accept-Language': 'en-US,en;q=0.9',
      }
    });
    
    if (!pageResponse.ok) {
      throw new Error("Failed to fetch video page. The video may be private or unavailable.");
    }
    
    const html = await pageResponse.text();
    
    // Extract all metadata
    const metadata = extractVideoMetadata(html, videoId);
    console.log(`[${correlationId}] Video: "${metadata.title}", Duration: ${metadata.duration}s, Chapters: ${metadata.chapters.length}`);
    
    // Check video duration
    if (metadata.duration && metadata.duration > 720) {
      console.log(`[${correlationId}] Video is ${Math.round(metadata.duration/60)} minutes - may have limited content`);
    }
    
    // Step 1: Try timedtext captions first (fastest and most reliable)
    let transcript = await fetchTimedtextTranscript(videoId);
    
    // Step 2: Try auto-generated captions from page HTML
    if (!transcript) {
      console.log(`[${correlationId}] Trying auto-generated captions...`);
      transcript = await fetchAutoGeneratedCaptions(html);
    }
    
    // Step 3: Use Lovable AI to generate study content from metadata
    if (!transcript) {
      console.log(`[${correlationId}] No captions found, using AI to generate content from metadata...`);
      transcript = await generateContentWithAI(metadata, videoId);
      
      if (transcript) {
        console.log(`[${correlationId}] âœ“ AI-generated content from video metadata`);
      }
    }
    
    // Step 4: Last resort - use description if substantial
    if (!transcript && metadata.description && metadata.description.length > 200) {
      console.log(`[${correlationId}] Using video description as content`);
      transcript = `# ${metadata.title}\n\n${metadata.description}`;
      
      if (metadata.chapters.length > 0) {
        transcript += `\n\n## Video Chapters\n${metadata.chapters.join('\n')}`;
      }
    }
    
    if (!transcript || transcript.length < 100) {
      throw new Error(
        "ðŸ“º Unable to extract content from this video.\n\n" +
        "This could happen if:\n" +
        "â€¢ The video doesn't have captions/subtitles\n" +
        "â€¢ The video description is too short\n" +
        "â€¢ The video is private or age-restricted\n\n" +
        "ðŸ’¡ Try instead:\n" +
        "âœ“ A video with captions (look for the CC button)\n" +
        "âœ“ An educational video with detailed description\n" +
        "âœ“ Upload slides or notes as PDF\n" +
        "âœ“ Paste an article URL from the web"
      );
    }

    console.log(`[${correlationId}] âœ“ Extracted ${transcript.length} characters of content`);

    // Limit content to reasonable size (~40k chars)
    const content = transcript.length > 40000 
      ? transcript.substring(0, 40000) + "\n\n[Content truncated to 40,000 characters]"
      : transcript;

    // Update source with content
    const { error: updateError } = await supabase
      .from("sources")
      .update({
        title: metadata.title,
        content: content,
        language: "en",
        status: "completed",
        error: null,
      })
      .eq("id", sourceId);

    if (updateError) throw updateError;

    // Trigger deck generation
    const { error: generateError } = await supabase.functions.invoke("generate-deck", {
      body: { sourceId },
    });

    if (generateError) {
      console.error(`[${correlationId}] Failed to trigger deck generation:`, generateError);
    }

    console.log(`[${correlationId}] âœ“ YouTube ingestion complete`);

    return new Response(
      JSON.stringify({ success: true, sourceId, correlationId }),
      { headers: { ...corsHeaders, "Content-Type": "application/json" } }
    );

  } catch (error: any) {
    console.error(`[${correlationId}] Error:`, error);
    const errorMessage = error.message || "Unknown error occurred";
    
    // Determine if this is a user error (400) or system error (500)
    const isUserError = errorMessage.includes("Unable to extract content") ||
                        errorMessage.includes("Invalid YouTube URL") ||
                        errorMessage.includes("Content too short") ||
                        errorMessage.includes("private or unavailable");
    const statusCode = isUserError ? 400 : 500;
    
    // Update source with error if we have the sourceId
    if (sourceId) {
      try {
        const supabaseUrl = Deno.env.get("SUPABASE_URL")!;
        const supabaseServiceKey = Deno.env.get("SUPABASE_SERVICE_ROLE_KEY")!;
        const supabase = createClient(supabaseUrl, supabaseServiceKey);
        
        await supabase
          .from("sources")
          .update({ status: "failed", error: errorMessage })
          .eq("id", sourceId);
      } catch (updateError) {
        console.error(`[${correlationId}] Failed to update source error:`, updateError);
      }
    }
    
    return new Response(
      JSON.stringify({ error: errorMessage, correlationId }),
      { status: statusCode, headers: { ...corsHeaders, "Content-Type": "application/json" } }
    );
  }
});